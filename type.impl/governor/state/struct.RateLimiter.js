(function() {
    var type_impls = Object.fromEntries([["omnisearch_mcp",[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Debug-for-RateLimiter%3CK,+S,+C,+MW%3E\" class=\"impl\"><a href=\"#impl-Debug-for-RateLimiter%3CK,+S,+C,+MW%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;K, S, C, MW&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.89.0/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a> for RateLimiter&lt;K, S, C, MW&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.89.0/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a>,\n    S: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.89.0/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a> + StateStore&lt;Key = K&gt;,\n    C: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.89.0/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a> + Clock,\n    MW: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.89.0/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a> + RateLimitingMiddleware&lt;&lt;C as Clock&gt;::Instant&gt;,\n    &lt;C as Clock&gt;::Instant: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.89.0/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a href=\"#method.fmt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.89.0/core/fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"https://doc.rust-lang.org/1.89.0/core/fmt/struct.Formatter.html\" title=\"struct core::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.89.0/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"https://doc.rust-lang.org/1.89.0/core/fmt/struct.Error.html\" title=\"struct core::fmt::Error\">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href=\"https://doc.rust-lang.org/1.89.0/core/fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details>","Debug","omnisearch_mcp::common::rate_limiter::ProviderRateLimiter"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-RateLimiter%3CK,+S,+C,+MW%3E\" class=\"impl\"><a href=\"#impl-RateLimiter%3CK,+S,+C,+MW%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;K, S, C, MW&gt; RateLimiter&lt;K, S, C, MW&gt;<div class=\"where\">where\n    K: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.89.0/core/hash/trait.Hash.html\" title=\"trait core::hash::Hash\">Hash</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/1.89.0/core/cmp/trait.Eq.html\" title=\"trait core::cmp::Eq\">Eq</a> + <a class=\"trait\" href=\"https://doc.rust-lang.org/1.89.0/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a>,\n    S: KeyedStateStore&lt;K&gt;,\n    C: ReasonablyRealtime,\n    MW: RateLimitingMiddleware&lt;&lt;C as Clock&gt;::Instant, NegativeOutcome = NotUntil&lt;&lt;C as Clock&gt;::Instant&gt;&gt;,</div></h3><div class=\"docblock\"><h4 id=\"keyed-rate-limiters---asyncawait\"><a class=\"doc-anchor\" href=\"#keyed-rate-limiters---asyncawait\">§</a>Keyed rate limiters - <code>async</code>/<code>await</code></h4></div></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.until_key_ready\" class=\"method\"><h4 class=\"code-header\">pub async fn <a class=\"fn\">until_key_ready</a>(\n    &amp;self,\n    key: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.89.0/std/primitive.reference.html\">&amp;K</a>,\n) -&gt; &lt;MW as RateLimitingMiddleware&lt;&lt;C as Clock&gt;::Instant&gt;&gt;::PositiveOutcome</h4></section></summary><div class=\"docblock\"><p>Asynchronously resolves as soon as the rate limiter allows it.</p>\n<p>When polled, the returned future either resolves immediately (in the case where the rate\nlimiter allows it), or else triggers an asynchronous delay, after which the rate limiter\nis polled again. This means that the future might resolve at some later time (depending\non what other measurements are made on the rate limiter).</p>\n<p>If multiple futures are dispatched against the rate limiter, it is advisable to use\n<a href=\"#method.until_ready_with_jitter\"><code>until_ready_with_jitter</code></a>, to avoid thundering herds.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.until_key_ready_with_jitter\" class=\"method\"><h4 class=\"code-header\">pub async fn <a class=\"fn\">until_key_ready_with_jitter</a>(\n    &amp;self,\n    key: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.89.0/std/primitive.reference.html\">&amp;K</a>,\n    jitter: Jitter,\n) -&gt; &lt;MW as RateLimitingMiddleware&lt;&lt;C as Clock&gt;::Instant&gt;&gt;::PositiveOutcome</h4></section></summary><div class=\"docblock\"><p>Asynchronously resolves as soon as the rate limiter allows it, with a randomized wait\nperiod.</p>\n<p>When polled, the returned future either resolves immediately (in the case where the rate\nlimiter allows it), or else triggers an asynchronous delay, after which the rate limiter\nis polled again. This means that the future might resolve at some later time (depending\non what other measurements are made on the rate limiter).</p>\n<p>This method allows for a randomized additional delay between polls of the rate limiter,\nwhich can help reduce the likelihood of thundering herd effects if multiple tasks try to\nwait on the same rate limiter.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.until_key_n_ready\" class=\"method\"><h4 class=\"code-header\">pub async fn <a class=\"fn\">until_key_n_ready</a>(\n    &amp;self,\n    key: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.89.0/std/primitive.reference.html\">&amp;K</a>,\n    n: <a class=\"struct\" href=\"https://doc.rust-lang.org/1.89.0/core/num/nonzero/struct.NonZero.html\" title=\"struct core::num::nonzero::NonZero\">NonZero</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.89.0/std/primitive.u32.html\">u32</a>&gt;,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;&lt;MW as RateLimitingMiddleware&lt;&lt;C as Clock&gt;::Instant&gt;&gt;::PositiveOutcome, InsufficientCapacity&gt;</h4></section></summary><div class=\"docblock\"><p>Asynchronously resolves as soon as the rate limiter allows it.</p>\n<p>This is similar to <code>until_key_ready</code> except it waits for an abitrary number\nof <code>n</code> cells to be available.</p>\n<p>Returns <code>InsufficientCapacity</code> if the <code>n</code> provided exceeds the maximum\ncapacity of the rate limiter.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.until_key_n_ready_with_jitter\" class=\"method\"><h4 class=\"code-header\">pub async fn <a class=\"fn\">until_key_n_ready_with_jitter</a>(\n    &amp;self,\n    key: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.89.0/std/primitive.reference.html\">&amp;K</a>,\n    n: <a class=\"struct\" href=\"https://doc.rust-lang.org/1.89.0/core/num/nonzero/struct.NonZero.html\" title=\"struct core::num::nonzero::NonZero\">NonZero</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.89.0/std/primitive.u32.html\">u32</a>&gt;,\n    jitter: Jitter,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;&lt;MW as RateLimitingMiddleware&lt;&lt;C as Clock&gt;::Instant&gt;&gt;::PositiveOutcome, InsufficientCapacity&gt;</h4></section></summary><div class=\"docblock\"><p>Asynchronously resolves as soon as the rate limiter allows it, with a\nrandomized wait period.</p>\n<p>This is similar to <code>until_key_ready_with_jitter</code> except it waits for an\nabitrary number of <code>n</code> cells to be available.</p>\n<p>Returns <code>InsufficientCapacity</code> if the <code>n</code> provided exceeds the maximum\ncapacity of the rate limiter.</p>\n</div></details></div></details>",0,"omnisearch_mcp::common::rate_limiter::ProviderRateLimiter"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-RateLimiter%3CK,+S,+C,+MW%3E\" class=\"impl\"><a href=\"#impl-RateLimiter%3CK,+S,+C,+MW%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;K, S, C, MW&gt; RateLimiter&lt;K, S, C, MW&gt;<div class=\"where\">where\n    S: KeyedStateStore&lt;K&gt;,\n    K: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.89.0/core/hash/trait.Hash.html\" title=\"trait core::hash::Hash\">Hash</a>,\n    C: Clock,\n    MW: RateLimitingMiddleware&lt;&lt;C as Clock&gt;::Instant&gt;,</div></h3><div class=\"docblock\"><h4 id=\"keyed-rate-limiters---manually-checking-cells\"><a class=\"doc-anchor\" href=\"#keyed-rate-limiters---manually-checking-cells\">§</a>Keyed rate limiters - Manually checking cells</h4></div></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.check_key\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">check_key</a>(\n    &amp;self,\n    key: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.89.0/std/primitive.reference.html\">&amp;K</a>,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;&lt;MW as RateLimitingMiddleware&lt;&lt;C as Clock&gt;::Instant&gt;&gt;::PositiveOutcome, &lt;MW as RateLimitingMiddleware&lt;&lt;C as Clock&gt;::Instant&gt;&gt;::NegativeOutcome&gt;</h4></section></summary><div class=\"docblock\"><p>Allow a single cell through the rate limiter for the given key.</p>\n<p>If the rate limit is reached, <code>check_key</code> returns information about the earliest\ntime that a cell might be allowed through again under that key.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.check_key_n\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">check_key_n</a>(\n    &amp;self,\n    key: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.89.0/std/primitive.reference.html\">&amp;K</a>,\n    n: <a class=\"struct\" href=\"https://doc.rust-lang.org/1.89.0/core/num/nonzero/struct.NonZero.html\" title=\"struct core::num::nonzero::NonZero\">NonZero</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.89.0/std/primitive.u32.html\">u32</a>&gt;,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"enum\" href=\"https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;&lt;MW as RateLimitingMiddleware&lt;&lt;C as Clock&gt;::Instant&gt;&gt;::PositiveOutcome, &lt;MW as RateLimitingMiddleware&lt;&lt;C as Clock&gt;::Instant&gt;&gt;::NegativeOutcome&gt;, InsufficientCapacity&gt;</h4></section></summary><div class=\"docblock\"><p>Allow <em>only all</em> <code>n</code> cells through the rate limiter for the given key.</p>\n<p>This method can succeed in only one way and fail in two ways:</p>\n<ul>\n<li>Success: If all <code>n</code> cells can be accommodated, it returns <code>Ok(Ok(()))</code>.</li>\n<li>Failure (but ok): Not all cells can make it through at the current time.\nThe result is <code>Ok(Err(NotUntil))</code>, which can\nbe interrogated about when the batch might next conform.</li>\n<li>Failure (the batch can never go through): The rate limit is too low for the given number\nof cells. The result is <code>Err(InsufficientCapacity)</code></li>\n</ul>\n<h6 id=\"performance\"><a class=\"doc-anchor\" href=\"#performance\">§</a>Performance</h6>\n<p>This method diverges a little from the GCRA algorithm, using\nmultiplication to determine the next theoretical arrival time, and so\nis not as fast as checking a single cell.</p>\n</div></details></div></details>",0,"omnisearch_mcp::common::rate_limiter::ProviderRateLimiter"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-RateLimiter%3CK,+S,+C,+MW%3E\" class=\"impl\"><a href=\"#impl-RateLimiter%3CK,+S,+C,+MW%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;K, S, C, MW&gt; RateLimiter&lt;K, S, C, MW&gt;<div class=\"where\">where\n    S: ShrinkableKeyedStateStore&lt;K&gt;,\n    K: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.89.0/core/hash/trait.Hash.html\" title=\"trait core::hash::Hash\">Hash</a>,\n    C: Clock,\n    MW: RateLimitingMiddleware&lt;&lt;C as Clock&gt;::Instant&gt;,</div></h3><div class=\"docblock\"><h4 id=\"keyed-rate-limiters---housekeeping\"><a class=\"doc-anchor\" href=\"#keyed-rate-limiters---housekeeping\">§</a>Keyed rate limiters - Housekeeping</h4>\n<p>As the inputs to a keyed rate-limiter can be arbitrary keys, the set of retained keys retained\ngrows, while the number of active keys may stay smaller. To save on space, a keyed rate-limiter\nallows removing those keys that are “stale”, i.e., whose values are no different from keys’ that\naren’t present in the rate limiter state store.</p>\n</div></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.retain_recent\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">retain_recent</a>(&amp;self)</h4></section></summary><div class=\"docblock\"><p>Retains all keys in the rate limiter that were used recently enough.</p>\n<p>Any key whose rate limiting state is indistinguishable from a “fresh” state (i.e., the\ntheoretical arrival time lies in the past).</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.shrink_to_fit\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">shrink_to_fit</a>(&amp;self)</h4></section></summary><div class=\"docblock\"><p>Shrinks the capacity of the rate limiter’s state store, if possible.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.len\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">len</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.89.0/std/primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Returns the number of “live” keys in the rate limiter’s state store.</p>\n<p>Depending on how the state store is implemented, this may\nreturn an estimate or an out-of-date result.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_empty\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">is_empty</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.89.0/std/primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if the rate limiter has no keys in it.</p>\n<p>As with <a href=\"#method.len\"><code>len</code></a>, this method may return\nimprecise results (indicating that the state store is empty\nwhile a concurrent rate-limiting operation is taking place).</p>\n</div></details></div></details>",0,"omnisearch_mcp::common::rate_limiter::ProviderRateLimiter"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-RateLimiter%3CK,+S,+C,+MW%3E\" class=\"impl\"><a href=\"#impl-RateLimiter%3CK,+S,+C,+MW%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;K, S, C, MW&gt; RateLimiter&lt;K, S, C, MW&gt;<div class=\"where\">where\n    S: StateStore&lt;Key = K&gt;,\n    C: Clock,\n    MW: RateLimitingMiddleware&lt;&lt;C as Clock&gt;::Instant&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.new\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">new</a>(quota: Quota, state: S, clock: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.89.0/std/primitive.reference.html\">&amp;C</a>) -&gt; RateLimiter&lt;K, S, C, MW&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a new rate limiter from components.</p>\n<p>This is the most generic way to construct a rate-limiter; most users should prefer\n[<code>direct</code>] or other methods instead.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.into_state_store\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">into_state_store</a>(self) -&gt; S</h4></section></summary><div class=\"docblock\"><p>Consumes the <code>RateLimiter</code> and returns the state store.</p>\n<p>This is mostly useful for debugging and testing.</p>\n</div></details></div></details>",0,"omnisearch_mcp::common::rate_limiter::ProviderRateLimiter"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-RateLimiter%3CK,+S,+C,+MW%3E\" class=\"impl\"><a href=\"#impl-RateLimiter%3CK,+S,+C,+MW%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;K, S, C, MW&gt; RateLimiter&lt;K, S, C, MW&gt;<div class=\"where\">where\n    S: StateStore&lt;Key = K&gt;,\n    C: Clock,\n    MW: RateLimitingMiddleware&lt;&lt;C as Clock&gt;::Instant&gt;,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.with_middleware\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">with_middleware</a>&lt;Outer&gt;(self) -&gt; RateLimiter&lt;K, S, C, Outer&gt;<div class=\"where\">where\n    Outer: RateLimitingMiddleware&lt;&lt;C as Clock&gt;::Instant&gt;,</div></h4></section></summary><div class=\"docblock\"><p>Convert the given rate limiter into one that uses a different middleware.</p>\n</div></details></div></details>",0,"omnisearch_mcp::common::rate_limiter::ProviderRateLimiter"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-RateLimiter%3CNotKeyed,+InMemoryState,+C,+NoOpMiddleware%3C%3CC+as+Clock%3E::Instant%3E%3E\" class=\"impl\"><a href=\"#impl-RateLimiter%3CNotKeyed,+InMemoryState,+C,+NoOpMiddleware%3C%3CC+as+Clock%3E::Instant%3E%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;C&gt; RateLimiter&lt;NotKeyed, InMemoryState, C, NoOpMiddleware&lt;&lt;C as Clock&gt;::Instant&gt;&gt;<div class=\"where\">where\n    C: Clock,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.direct_with_clock\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">direct_with_clock</a>(\n    quota: Quota,\n    clock: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.89.0/std/primitive.reference.html\">&amp;C</a>,\n) -&gt; RateLimiter&lt;NotKeyed, InMemoryState, C, NoOpMiddleware&lt;&lt;C as Clock&gt;::Instant&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Constructs a new direct rate limiter for a quota with a custom clock.</p>\n</div></details></div></details>",0,"omnisearch_mcp::common::rate_limiter::ProviderRateLimiter"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-RateLimiter%3CNotKeyed,+InMemoryState,+QuantaClock%3E\" class=\"impl\"><a href=\"#impl-RateLimiter%3CNotKeyed,+InMemoryState,+QuantaClock%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl RateLimiter&lt;NotKeyed, InMemoryState, QuantaClock&gt;</h3><div class=\"docblock\"><h4 id=\"direct-in-memory-rate-limiters---constructors\"><a class=\"doc-anchor\" href=\"#direct-in-memory-rate-limiters---constructors\">§</a>Direct in-memory rate limiters - Constructors</h4>\n<p>Here we construct an in-memory rate limiter that makes direct (un-keyed)\nrate-limiting decisions. Direct rate limiters can be used to\ne.g. regulate the transmission of packets on a single connection,\nor to ensure that an API client stays within a service’s rate\nlimit.</p>\n</div></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.direct\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">direct</a>(quota: Quota) -&gt; RateLimiter&lt;NotKeyed, InMemoryState, QuantaClock&gt;</h4></section></summary><div class=\"docblock\"><p>Constructs a new in-memory direct rate limiter for a quota with the default real-time clock.</p>\n</div></details></div></details>",0,"omnisearch_mcp::common::rate_limiter::ProviderRateLimiter"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-RateLimiter%3CNotKeyed,+S,+C,+MW%3E\" class=\"impl\"><a href=\"#impl-RateLimiter%3CNotKeyed,+S,+C,+MW%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;S, C, MW&gt; RateLimiter&lt;NotKeyed, S, C, MW&gt;<div class=\"where\">where\n    S: DirectStateStore,\n    C: Clock,\n    MW: RateLimitingMiddleware&lt;&lt;C as Clock&gt;::Instant&gt;,</div></h3><div class=\"docblock\"><h4 id=\"direct-rate-limiters---manually-checking-cells\"><a class=\"doc-anchor\" href=\"#direct-rate-limiters---manually-checking-cells\">§</a>Direct rate limiters - Manually checking cells</h4></div></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.check\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">check</a>(\n    &amp;self,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;&lt;MW as RateLimitingMiddleware&lt;&lt;C as Clock&gt;::Instant&gt;&gt;::PositiveOutcome, &lt;MW as RateLimitingMiddleware&lt;&lt;C as Clock&gt;::Instant&gt;&gt;::NegativeOutcome&gt;</h4></section></summary><div class=\"docblock\"><p>Allow a single cell through the rate limiter.</p>\n<p>If the rate limit is reached, <code>check</code> returns information about the earliest\ntime that a cell might be allowed through again.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.check_n\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">check_n</a>(\n    &amp;self,\n    n: <a class=\"struct\" href=\"https://doc.rust-lang.org/1.89.0/core/num/nonzero/struct.NonZero.html\" title=\"struct core::num::nonzero::NonZero\">NonZero</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.89.0/std/primitive.u32.html\">u32</a>&gt;,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"enum\" href=\"https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;&lt;MW as RateLimitingMiddleware&lt;&lt;C as Clock&gt;::Instant&gt;&gt;::PositiveOutcome, &lt;MW as RateLimitingMiddleware&lt;&lt;C as Clock&gt;::Instant&gt;&gt;::NegativeOutcome&gt;, InsufficientCapacity&gt;</h4></section></summary><div class=\"docblock\"><p>Allow <em>only all</em> <code>n</code> cells through the rate limiter.</p>\n<p>This method can succeed in only one way and fail in two ways:</p>\n<ul>\n<li>Success: If all <code>n</code> cells can be accommodated, it returns <code>Ok(())</code>.</li>\n<li>Failure (but ok): Not all cells can make it through at the current time.\nThe result is <code>Err(NegativeMultiDecision::BatchNonConforming(NotUntil))</code>, which can\nbe interrogated about when the batch might next conform.</li>\n<li>Failure (the batch can never go through): The rate limit quota’s burst size is too low\nfor the given number of cells to ever be allowed through.</li>\n</ul>\n<h6 id=\"performance\"><a class=\"doc-anchor\" href=\"#performance\">§</a>Performance</h6>\n<p>This method diverges a little from the GCRA algorithm, using\nmultiplication to determine the next theoretical arrival time, and so\nis not as fast as checking a single cell.</p>\n</div></details></div></details>",0,"omnisearch_mcp::common::rate_limiter::ProviderRateLimiter"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-RateLimiter%3CNotKeyed,+S,+C,+MW%3E\" class=\"impl\"><a href=\"#impl-RateLimiter%3CNotKeyed,+S,+C,+MW%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;S, C, MW&gt; RateLimiter&lt;NotKeyed, S, C, MW&gt;<div class=\"where\">where\n    S: DirectStateStore,\n    C: ReasonablyRealtime,\n    MW: RateLimitingMiddleware&lt;&lt;C as Clock&gt;::Instant, NegativeOutcome = NotUntil&lt;&lt;C as Clock&gt;::Instant&gt;&gt;,</div></h3><div class=\"docblock\"><h4 id=\"direct-rate-limiters---asyncawait\"><a class=\"doc-anchor\" href=\"#direct-rate-limiters---asyncawait\">§</a>Direct rate limiters - <code>async</code>/<code>await</code></h4></div></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.until_ready\" class=\"method\"><h4 class=\"code-header\">pub async fn <a class=\"fn\">until_ready</a>(\n    &amp;self,\n) -&gt; &lt;MW as RateLimitingMiddleware&lt;&lt;C as Clock&gt;::Instant&gt;&gt;::PositiveOutcome</h4></section></summary><div class=\"docblock\"><p>Asynchronously resolves as soon as the rate limiter allows it.</p>\n<p>When polled, the returned future either resolves immediately (in the case where the rate\nlimiter allows it), or else triggers an asynchronous delay, after which the rate limiter\nis polled again. This means that the future might resolve at some later time (depending\non what other measurements are made on the rate limiter).</p>\n<p>If multiple futures are dispatched against the rate limiter, it is advisable to use\n<a href=\"#method.until_ready_with_jitter\"><code>until_ready_with_jitter</code></a>, to avoid thundering herds.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.until_ready_with_jitter\" class=\"method\"><h4 class=\"code-header\">pub async fn <a class=\"fn\">until_ready_with_jitter</a>(\n    &amp;self,\n    jitter: Jitter,\n) -&gt; &lt;MW as RateLimitingMiddleware&lt;&lt;C as Clock&gt;::Instant&gt;&gt;::PositiveOutcome</h4></section></summary><div class=\"docblock\"><p>Asynchronously resolves as soon as the rate limiter allows it, with a randomized wait\nperiod.</p>\n<p>When polled, the returned future either resolves immediately (in the case where the rate\nlimiter allows it), or else triggers an asynchronous delay, after which the rate limiter\nis polled again. This means that the future might resolve at some later time (depending\non what other measurements are made on the rate limiter).</p>\n<p>This method allows for a randomized additional delay between polls of the rate limiter,\nwhich can help reduce the likelihood of thundering herd effects if multiple tasks try to\nwait on the same rate limiter.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.until_n_ready\" class=\"method\"><h4 class=\"code-header\">pub async fn <a class=\"fn\">until_n_ready</a>(\n    &amp;self,\n    n: <a class=\"struct\" href=\"https://doc.rust-lang.org/1.89.0/core/num/nonzero/struct.NonZero.html\" title=\"struct core::num::nonzero::NonZero\">NonZero</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.89.0/std/primitive.u32.html\">u32</a>&gt;,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;&lt;MW as RateLimitingMiddleware&lt;&lt;C as Clock&gt;::Instant&gt;&gt;::PositiveOutcome, InsufficientCapacity&gt;</h4></section></summary><div class=\"docblock\"><p>Asynchronously resolves as soon as the rate limiter allows it.</p>\n<p>This is similar to <code>until_ready</code> except it waits for an abitrary number\nof <code>n</code> cells to be available.</p>\n<p>Returns <code>InsufficientCapacity</code> if the <code>n</code> provided exceeds the maximum\ncapacity of the rate limiter.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.until_n_ready_with_jitter\" class=\"method\"><h4 class=\"code-header\">pub async fn <a class=\"fn\">until_n_ready_with_jitter</a>(\n    &amp;self,\n    n: <a class=\"struct\" href=\"https://doc.rust-lang.org/1.89.0/core/num/nonzero/struct.NonZero.html\" title=\"struct core::num::nonzero::NonZero\">NonZero</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.89.0/std/primitive.u32.html\">u32</a>&gt;,\n    jitter: Jitter,\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.89.0/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;&lt;MW as RateLimitingMiddleware&lt;&lt;C as Clock&gt;::Instant&gt;&gt;::PositiveOutcome, InsufficientCapacity&gt;</h4></section></summary><div class=\"docblock\"><p>Asynchronously resolves as soon as the rate limiter allows it, with a\nrandomized wait period.</p>\n<p>This is similar to <code>until_ready_with_jitter</code> except it waits for an\nabitrary number of <code>n</code> cells to be available.</p>\n<p>Returns <code>InsufficientCapacity</code> if the <code>n</code> provided exceeds the maximum\ncapacity of the rate limiter.</p>\n</div></details></div></details>",0,"omnisearch_mcp::common::rate_limiter::ProviderRateLimiter"]]]]);
    if (window.register_type_impls) {
        window.register_type_impls(type_impls);
    } else {
        window.pending_type_impls = type_impls;
    }
})()
//{"start":55,"fragment_lengths":[29619]}